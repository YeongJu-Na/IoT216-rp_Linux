# IoT216-rp_Linux
### 실습 내용
- Lect 1, 2: 라즈베리파이 시작하기
  - sd카드 포맷
  - raspbian(raspberry Pi OS) 다운 → sd카드에 os porting, rasperry pi에 삽입
  - KBD/Mouse/Monitor 라즈베리파이에 연결 및 전원 인가
  - 해상도 - raspi-config 툴이용해서 해상도 설정 높이기(default; 640x480)
  - vnc 활성화 --> virtual network computing
    - raspberry pi configuration에서 vnc, ssh → enable로⇒ 원격제어 가능 상태--> 입출력 장치 해제 가능
  - wifi 사용 가능(고정 IP 미확보 → 고정 IP설정): 콘솔창 ifconfig에서 inet: ip번호 확인하기
    - wifi모양 우클릭 > wireless설정> ipv4주소: 확인한 ip번호 입력, router: gateway(192.168.0.1) ⇒ reboot
    - 윈도우즈에서 ping ip주소 --> 해당 ip 도달 가능여부 확인
  - 입출력 장치 해제, 윈도우즈로, vnc뷰어 설치 →확인한 IP주소입력, username:pi, ps:raspberry →pc에서 원격접속
  - sudo apt-get update/ upgrade ⇒ 한글 입출력 모듈 설치 (ibus), 폰트 설치
  - >> 한글 오류: raspberry pi configuration> localisation> locale > 언어를 영어(en), us, utf-8
  - samba설치 및 설정 ⇒ pc에서 NFS사용 위함 ==> Network File System
    - samba설치: sudo apt-get install samba-common-bin 
    - root권한으로 설정하기 : sudo passwd> 새 암호 설정 → su입력 후 새 암호 입력
    - --> sudo passwd 남발하면 안됨!!
    - pi > Work파일 만들기 → /etc/samba로 이동 → nano smb.conf 입력 후 마지막에(nano ==> 편집기(vim도 있음))
    - 마지막에 아래 내용 입력 후 저장(ctrl+o) 후 나가기(ctrl+x)
    - --> shift + : ==> 맨 아래로, q!입력 시 저장없이 빠져나옴
    - > [pi]   path=/home/pi/Work writeable=Yes create mask=0777 directory mask=0777   public=no
    - systemctl restart smbd (--> smbd의 d는 데몬)
    - 윈도우즈 파일탐색기에서 라즈비안 ip입력→ \\192.168.0.2(앞에 백슬래시 두개 필요)
  - >> 오류: failed to restart smbd.service unit not found 
    - sudo apt-get remove samba 후에 다시 깔기 → sudo apt-get install samba → restart 성공~!
- Lect 2: gcc(GNU Compiler Collection)
  - hello.c 파일 만들기 --> gcc -o hello hello.c
    - 옵션: -o, output, hello.c 컴파일하여 실행파일 생성 
    - ls -al해보면 녹색으로 hello파일 볼 수 있으며 기존 hello.c와 비교해서 x권한, 즉 실행 가능함이 
  - hello실행시키기 --> ./hello 
    - ./는 현재 경로로, 파일 실행시키기 위해서는 해당 파일 경로와 파일명을 함께 작성해야 함
- Lect 3: gcc, GetToken함수 만들기
  - SSH: secure shell(보안 쉘)
    - 원격지 호스트 커멩서 접속 위해 사용되는 인터넷 프로토콜 --> 기본적으로 CLI상에서 작업, 기본 포트 22
    - 기존 유닉스 시스템 쉘에 원격 접속 시 사용되던 텔넷은 암호화 없어 계정정보 탈취 위험
    - ssh키: ssh client(로컬머신,비공개키), ssh server(원격머신, 공개키) ==> 서버 접속 시 비번 대신 키 제출
  - putty: 터미널 에뮬레이터, ssh이용 위해 사용 --> 원격으로 쉘 이용 가능하게 함
  - VNC로 라즈베리파이 내부에 GetToken 함수만들기
    - char ** 
    - FILE*
- Lect 4: getToken, makefile, wiringPi
  - getToken
    - 문자열 str을 deli로 구분하여 idx위치의 문자열 반환
    - > 오류: 반환할 문자열을 담을 char *를 함수 내에서 malloc으로 생성 후 반환 시 null
    - 지역변수라서 clear됨 → 매개변수에 결과를 담을 문자열 추가
  - makefile 만드는 과정
    - myHeader.h 파일 만들고 함수 프로토타입들 옮기기 → 기존hello.c에서 원형들 삭제 후 #include “myHeader.h” → 인용부호로 된 것은 시스템 제공 외 로컬 디렉토리 안에서 참조o
    - usr폴더 > include디렉토리 > 이 안의 헤더 파일들(시스템헤더파일)을 <>로 include가능 
    - myLib.c파일 생성 후 함수 정의한 것 옮기기+#include → 실행시 gcc -o hello hello.c myLilb.c
    - makefile생성
    - > CC = gcc   CFLAGS = -g   OBJS = hello.o myLib.o   TARGET = hello   hello : hello.o myLib.o   	$(CC) -o $@ $(OBJS)   hello.o : hello.c myHeader.h   myLib.o : myLib.c
    - 저장 후 make명령 → ls -al 하면 .o파일 생성됨(makefile안에 clean레이블이 이런 중간 파일들 없애주는 역할)
    - > clean :   $(RM) $(OBJS) $(TARGET) core   → make clean 
  - make file: 파일관리 유틸리티, 파일 간의 종속관계 파악해서 Makefile(기술파일)에 적힌 대로 컴파일러에 명령
    - --> SHELL 명령이 순차적으로 실행될 수 있게 함
    - 대문자: macro
    - CC: 컴파일러
    - CFLAGS: 옵션
    - 아래줄에서 $(macro명)
    - “label :  “: 각각의 태그?
    - --> $@: current target
    - --> $^: output file구성 위한 목록들
  - wiringPi.h
    - wiringPiSetup()
    - 
    - digital
    - gcc -o led LEDcontrol.c -lwiringPi  // -l: link옵션

---------------
### 이론
- 컴파일 과정
  - 전처리 단계: #으로 시작하는 지시자 처리(.c)
  - 컴파일 단계: 어셈블리어로 (.i)
  - 어셈블리 단계: 쪼개서 instruction단위로 만들어 모아 재배치 가능한 목적 프로그램 단위로 (.s)
    - 재배치 가능 = 링커를 통해 다른 목적파일들과 결합 가능 의미
    - 바이너리 파일 생성 
    - gcc -o, *.o
  - 링킹 단계: 목적 파일 엮어서 하나의 실행 파일로(.o)
    - 바이너리 파일
  - executable object program
- GCC(GNU C Compiler)
  - 어셈블리 단계와 링킹 단계
  - --help: 

- 리눅스 명령어
  - cd: change directory, 디렉토리 이동
    - ~: 홈디렉토리로 바로 이동 --> cd ~
    - cd ..: 상위 디렉토리로
    - cd -: 이동 직전의 디렉토리로 이동
  - ls: list segments, 파일과 디렉토리의 모든 정보 제공
    - 옵션
    - -a: all, 숨겨진 파일이나 디렉토리도 보여줌
    - -l: long, (read,write,exec 권한 알 수 o-> 권한 존재를 1로 표현해서 111(7)로도 표현)-> root/소유자/유저
    - -al: 위 2개 함께 쓰기
    - -t: 파일들을 생성된 시간 별로 표시 --> 최신부터
  - pwd: print work directory, 현재 작업 중인 디렉터리 표시
  - cat: concatenate파일 내용 화면에 출력하거나 파일 만드는 명령어
  - sudo: su(super user), 권한이 없는 사용자는 낮은 수준의 권한이 필요한 파일에 액세스, 수정 가능
  - apt-get: 패키지 관리 명령어 도구
    - upgrade, install, remove
  - exit
  - 버전 확인하기 ex) gcc -v  // gcc 컴파일러 버전 확인
  - - redirection: 리눅스 스트림의 방향 조정 (stream개념 확실히 잡아야- c/c++에서 stdin, stdout)
    - >: 명령의 결과를 파일로 저장
    - >>: 명령 결과를 파일에 추가
    - <: 파일의 데이터를 명령에 입력
  - ".": 현재 디렉토리
  - "..": parent directory, 상위 디렉토리
- 사용자 
  - $: 일반 유저
  - #: root권한
------------
### C언어
- #include <conio.h> 유닉스에서x → key event x 
    - 한사람이 키보드를 독점하는 이벤트 사용 불가, 유닉스 멀티 유저 기반? 이므로
    - getch()대신 표준함수인 getchar()써야
- FILE *fp = fopen(“test.txt”,”ab”);
    - 파일 다루는데 익숙해져야
    - FILE *fp  = fopen(“파일명(파일경로)”,”옵션”);
  - 옵션
    - a옵션: append(기존에 있으면 추가, 없으면 생성해서 추가)
    - b옵션: binary형태의 데이터형태(없는 것과 차이는 \n처리만 차이)
  - fscanf, fprintf: scanf, printf 사용법과 동일하나, 파일 포인터 매개변수만 추가하면 됨 
    - fprintf(fp,”%s”,buf); 파일로 내보냄 / fscanf(fp,”%s”,str); 파일 내용 받아옴
  - fclose(fp);  // 반드시 닫아줘야
- c와 c# 차이 
    - c#에서 while 안에는 bool, c는 0외 숫자(true)/ 0(false)도 가능 
    - c#에서는 null → c에서는 NULL
    - c는 함수 이름 같은거 하나만 가능(함수 오버로드x) → EX, EX1, `~~
- <string.h>
    - strlen함수
    - strcpy함수
    - strncpy → strcpy에 복사할 길이(사이즈) 인수 하나 더
    - → 복사한 문자열 마지막에 null(0)처리 안함 → 별도로 해줘야
- ** : 포인터의 포인터 
- 문자열
    - char[] → 괄호 안에 반드시 상수써야
    - char 무조건 1byte, 한글은 2byte, 문자열 끝에 반드시 null → split시 사용
- malloc: memory allocation
  - free
    - 메모리 누수 발생 가능성: free(메모리 개방)
    - 쓰고 안닫으면? segmentation error → 그냥 모든 ㅇㅔ러인가?
  - size
    - default는 1바이트 = 1 char(1byte)
    - char** ar2 = malloc(cnt(str)*sizeof(char*));	// 포인터 변수의 크기(32bit면 4바이트)
  - stack 영역 x→ data영역차지(시스템 종료 후에도 남아 있으니 free해야한다)
    - ⇒ 코드영역과 스택영역은 로컬 데이터 공유
- 사용자 정의 함수에서 만든 지역변수를 리턴 → stack영역(재사용영역)
    - 리턴 시, clear되서 null됨
